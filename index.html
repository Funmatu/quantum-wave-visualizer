<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6D Quantum Hyper-Spatial Visualizer Pro</title>
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    
    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; color: #f8fafc; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        .ui-overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; }
        .stats-panel {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(15, 23, 42, 0.85);
            padding: 20px; border-radius: 12px; border: 1px solid rgba(56, 189, 248, 0.3);
            backdrop-filter: blur(12px); width: 300px; z-index: 10;
        }
        .mode-description {
            position: absolute; top: 20px; right: 60px;
            background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 30px;
            border: 1px dashed #38bdf8; font-size: 0.8rem; color: #7dd3fc;
        }
        .dim-tag { background: #075985; color: #e0f2fe; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: bold; }
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020617; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
        }
    </style>
</head>
<body>

<div id="loading">
    <div class="text-2xl font-light tracking-widest text-sky-400 animate-pulse">QUANTUM WAVEFORM COHERENCE...</div>
    <div class="mt-6 w-64 h-1 bg-slate-800 rounded-full overflow-hidden">
        <div id="progress-bar" class="w-0 h-full bg-sky-500 transition-all duration-700"></div>
    </div>
</div>

<div class="ui-overlay">
    <h1 class="text-3xl font-black tracking-tighter text-sky-400">6D QUANTUM ANALYZER <span class="text-xs font-normal border px-2 py-1 rounded ml-2">PRO v2.1</span></h1>
    <p class="text-sm text-sky-600 font-mono mt-1">Wave Packet Evolution: R³ (Space) + C¹ (Phase) + T¹ (Time)</p>
</div>

<div id="mode-info" class="mode-description">
    Loading Mode Data...
</div>

<div class="stats-panel">
    <div class="text-sky-400 text-xs font-bold border-b border-sky-900 pb-2 mb-3 tracking-widest uppercase">Waveform Telemetry</div>
    <div class="space-y-2 text-xs font-mono">
        <div class="flex justify-between"><span>Density |Ψ|²:</span> <span id="val-density" class="text-sky-300">0.000</span></div>
        <div class="flex justify-between"><span>Phase Arg(Ψ):</span> <span id="val-phase" class="text-sky-300">0.00 rad</span></div>
        <div class="flex justify-between"><span>Coherence σ:</span> <span id="val-sigma" class="text-sky-300">1.20</span></div>
        <div class="flex justify-between"><span>Momentum k:</span> <span id="val-momentum" class="text-sky-300">4.00</span></div>
    </div>
    <div class="mt-4 h-20 w-full bg-black/40 rounded border border-sky-900/50 relative overflow-hidden">
        <canvas id="wave-canvas"></canvas>
    </div>
    <div class="mt-4 text-[10px] text-slate-500 italic">
        * Mouse to Orbit | Scroll to Zoom | Drag to Rotate
    </div>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
    varying float vAmp;
    varying float vPhase;

    uniform float uTime;
    uniform float uSigma0;
    uniform float uKx;
    uniform float uKy;
    uniform float uKz;
    uniform float uDispersion;
    uniform int uViewMode; // 0: Physical, 1: Complex Plane

    void main() {
        float t = uTime * 0.5;
        float s0 = uSigma0;
        
        // --- Core Quantum Physics ---
        // sigma(t)^2 = s0^2 + i*t*dispersion
        float reS2 = s0 * s0;
        float imS2 = t * uDispersion;
        float magS2 = reS2 * reS2 + imS2 * imS2;

        // Gaussian Amplitude Distribution
        float r2 = dot(position, position);
        float amp = exp(- (r2 * reS2) / (4.0 * magS2));
        
        // Quantum Phase Rotation
        float phase = (uKx * position.x + uKy * position.y + uKz * position.z) 
                    - (0.5 * (uKx*uKx + uKy*uKy + uKz*uKz) * t)
                    + (r2 * imS2) / (4.0 * magS2);

        vAmp = amp;
        vPhase = phase;

        vec3 targetPos = position;

        if (uViewMode == 0) {
            // MODE 0: PHYSICAL SPACE (R3)
            // Visualizing the cloud with subtle phase-induced oscillation
            targetPos = position + vec3(
                cos(phase) * amp * 0.3,
                sin(phase) * amp * 0.3,
                0.0
            );
        } else {
            // MODE 1: COMPLEX PLANE PROJECTION (R1 + C1)
            // X-axis is physical space. Y is Real part, Z is Imaginary part.
            float vizScale = 6.0;
            targetPos.x = position.x; 
            targetPos.y = amp * cos(phase) * vizScale; // Real Part
            targetPos.z = amp * sin(phase) * vizScale; // Imaginary Part
        }

        vec4 mvPosition = modelViewMatrix * vec4(targetPos, 1.0);
        
        // Adaptive point size for depth and mode clarity
        float pSize = (uViewMode == 1) ? 5.0 : (amp * 16.0);
        gl_PointSize = pSize * (350.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    varying float vAmp;
    varying float vPhase;

    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    void main() {
        if (vAmp < 0.01) discard;

        // Map phase to high-fidelity spectrum
        float hue = fract(vPhase / 6.28318);
        vec3 color = hsv2rgb(vec3(hue, 0.75, 1.0));
        
        float dist = distance(gl_PointCoord, vec2(0.5));
        if (dist > 0.5) discard;
        
        // Soft-body particle rendering
        float alpha = vAmp * (1.0 - dist * 2.1);
        gl_FragColor = vec4(color, alpha * 0.85);
    }
</script>

<script>
    let scene, camera, renderer, composer, controls, packet, bloomPass;
    let clock = new THREE.Clock();
    
    const params = {
        sigma: 1.2,
        kx: 4.0, ky: 0.0, kz: 0.0,
        dispersion: 1.5,
        viewMode: 'Physical Cloud (XYZ)',
        pointCount: 120000,
        bloomStrength: 1.2,
        resetTime: () => { clock = new THREE.Clock(); }
    };

    const MODES = {
        'Physical Cloud (XYZ)': 0,
        'Complex Spiral (X/Re/Im)': 1
    };

    const DESCRIPTIONS = {
        0: "物理空間：3次元空間における粒子の「存在確率密度」を表示。光る場所ほど見つかりやすい。",
        1: "複素平面：X軸上の波が実部(Y)と虚部(Z)で回転する螺旋（コルクスクリュー）構造を可視化。"
    };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(12, 8, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x020617);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const renderScene = new THREE.RenderPass(scene, camera);
        bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomStrength, 0.4, 0.85
        );
        bloomPass.threshold = 0;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Improved Spherical Geometry Creation ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(params.pointCount * 3);
        const radiusRange = 25; 

        for (let i = 0; i < params.pointCount; i++) {
            // Uniform distribution within a sphere
            const theta = Math.random() * Math.PI * 2; // Horizontal angle
            const phi = Math.acos((Math.random() * 2) - 1); // Vertical angle
            const r = Math.cbrt(Math.random()) * radiusRange; // Cube root for uniform volume density

            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSigma0: { value: params.sigma },
                uKx: { value: params.kx }, uKy: { value: params.ky }, uKz: { value: params.kz },
                uDispersion: { value: params.dispersion },
                uViewMode: { value: 0 }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        packet = new THREE.Points(geometry, material);
        scene.add(packet);

        const grid = new THREE.GridHelper(50, 50, 0x1e293b, 0x0f172a);
        grid.position.y = -8;
        scene.add(grid);

        // GUI
        const gui = new dat.GUI();
        const f1 = gui.addFolder('Wave Packet Physics');
        f1.add(params, 'sigma', 0.5, 4.0).name('Uncertainty σ').onChange(v => material.uniforms.uSigma0.value = v);
        f1.add(params, 'kx', -10, 10).name('Momentum Kx').onChange(v => material.uniforms.uKx.value = v);
        f1.add(params, 'dispersion', 0.1, 5.0).name('Dispersion Factor').onChange(v => material.uniforms.uDispersion.value = v);
        f1.add(params, 'resetTime').name('Reset Evolution');
        f1.open();

        const f2 = gui.addFolder('Dimensional Projection');
        f2.add(params, 'viewMode', Object.keys(MODES)).name('View Mode').onChange(v => {
            const mode = MODES[v];
            material.uniforms.uViewMode.value = mode;
            bloomPass.strength = (mode === 1) ? 0.6 : 1.2;
            document.getElementById('mode-info').innerText = DESCRIPTIONS[mode];
        });
        f2.add(params, 'bloomStrength', 0, 3).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        f2.open();

        document.getElementById('mode-info').innerText = DESCRIPTIONS[0];
        document.getElementById('progress-bar').style.width = '100%';
        setTimeout(() => {
            gsap.to('#loading', { opacity: 0, duration: 1, onComplete: () => {
                document.getElementById('loading').style.display = 'none';
            }});
        }, 1000);

        window.addEventListener('resize', onWindowResize, false);
        setupMiniWave();
        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    let waveCtx, waveCanvas;
    function setupMiniWave() {
        waveCanvas = document.getElementById('wave-canvas');
        waveCtx = waveCanvas.getContext('2d');
        waveCanvas.width = 300;
        waveCanvas.height = 80;
    }

    function updateStats(t) {
        const currentSigma = params.sigma + t * (params.dispersion * 0.04);
        document.getElementById('val-density').innerText = (Math.exp(-t * 0.05)).toFixed(3);
        document.getElementById('val-phase').innerText = (t * 5.0 % (Math.PI * 2)).toFixed(2) + " rad";
        document.getElementById('val-sigma').innerText = currentSigma.toFixed(2);
        document.getElementById('val-momentum').innerText = Math.abs(params.kx).toFixed(2);

        waveCtx.clearRect(0,0,300,80);
        waveCtx.beginPath();
        waveCtx.strokeStyle = '#38bdf8';
        waveCtx.lineWidth = 1.5;
        for(let x=0; x<300; x++) {
            let normX = (x - 150) / 70;
            let envelope = Math.exp(-Math.pow(normX, 2) / (currentSigma * 0.3));
            let wave = Math.sin(x * 0.2 - t * 15);
            let y = 40 + wave * envelope * 30;
            if(x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y);
        }
        waveCtx.stroke();
    }

    function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        packet.material.uniforms.uTime.value = elapsed;
        controls.update();
        updateStats(elapsed);
        composer.render();
    }

    window.onload = init;
</script>
</body>
</html>
